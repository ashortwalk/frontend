<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Map with Tmap API</title>
    <style>
      #map_div {
        width: 280px;
        height: 280px;
      }
      #result {
        margin-top: 20px;
      }
    </style>
    <!-- Include Tmap JavaScript API -->
    <script src="https://apis.openapi.sk.com/tmap/jsv2?version=1&appKey=REACT_APP_TMAP_API_KEY"></script>
  </head>
  <body>
    <div id="map_div"></div>
    <p id="result"></p>
    <input id="address" />
    <button id="drawLineBtn">경로 그리기</button>

    <script>
      const { Tmapv2 } = window;

      let map;
      let marker_s, marker_e;
      let drawInfoArr = [];
      let resultdrawArr = [];

      async function gpt(address) {
        const keyRespnose = await fetch("http://127.0.0.1:8000/api/key/gpt");
        const keyResult = await keyRespnose.json();
        const key = keyResult.gptKey;
        const promptData = {
          messages: [
            {
              role: "system",
              content:
                "너는 주어진 문장을 해석해서 도로명주소만을 배열에 담아 json으로 감싸 출력하는 AI야.",
            },
            {
              role: "user",
              content: `${address}에서 출발하고 끝나는 총 3km의 왕복 산책 코스의 출발지와 중간지점 5개와 도착지의 도로명주소를 배열에 담아 줘.`,
            },
          ],
        };
        const gptResponse = await fetch(
          "https://warme-m3p2wioi-francecentral.cognitiveservices.azure.com/openai/deployments/gpt-35-turbo/chat/completions?api-version=2024-08-01-preview",
          {
            method: "POST",
            headers: { "api-key": key, "Content-Type": "application/json" },
            body: JSON.stringify(promptData),
          }
        );
        const gptResult = await gptResponse.json();
        const result = JSON.parse(gptResult.choices[0].message.content);
        return result;
      }

      function initTmap() {
        const mapDiv = document.getElementById("map_div");

        if (!mapDiv.firstChild) {
          map = new Tmapv2.Map("map_div", {
            center: new Tmapv2.LatLng(37.566481622437934, 126.98502302169841),
            width: "280px",
            height: "280px",
            zoom: 15,
          });
        }
      }

      // Fetch route data asynchronously
      async function fetchRouteData() {
        const headers = { appKey: "REACT_APP_TMAP_API_KEY" };
        const requestData = {
          startX: "126.983937",
          startY: "37.564991",
          endX: "126.988940",
          endY: "37.566158",
          reqCoordType: "WGS84GEO",
          resCoordType: "EPSG3857",
          startName: "출발지",
          endName: "도착지",
        };

        try {
          const response = await fetch(
            "https://apis.openapi.sk.com/tmap/routes/pedestrian?version=1&format=json&callback=result",
            {
              method: "POST",
              headers: headers,
              body: JSON.stringify(requestData),
            }
          );

          const data = await response.json();

          if (response.ok) {
            processRouteData(data);
          } else {
            throw new Error("Failed to fetch route data");
          }
        } catch (error) {
          console.log("Error:", error);
        }
      }

      // Process and display the route data
      function processRouteData(responseData) {
        const resultData = responseData.features;

        const tDistance = `총 거리 : ${(
          resultData[0].properties.totalDistance / 1000
        ).toFixed(1)}km,`;
        const tTime = ` 총 시간 : ${(
          resultData[0].properties.totalTime / 60
        ).toFixed(0)}분`;
        document.querySelector("#result").innerHTML = tDistance + tTime;

        // Clear existing markers and polylines
        resultdrawArr.forEach((marker) => marker.setMap(null));
        resultdrawArr = [];
        drawInfoArr = [];

        resultData.forEach((feature) => {
          const { geometry, properties } = feature;
          if (geometry.type === "LineString") {
            geometry.coordinates.forEach((coordinate) => {
              const latlng = new Tmapv2.Point(coordinate[0], coordinate[1]);
              const convertPoint =
                new Tmapv2.Projection.convertEPSG3857ToWGS84GEO(latlng);
              const convertChange = new Tmapv2.LatLng(
                convertPoint._lat,
                convertPoint._lng
              );
              drawInfoArr.push(convertChange);
            });
          } else {
            let markerImg = "";
            let size;

            if (properties.pointType === "S") {
              markerImg = "/upload/tmap/marker/pin_r_m_s.png";
              size = new Tmapv2.Size(24, 38);
            } else if (properties.pointType === "E") {
              markerImg = "/upload/tmap/marker/pin_r_m_e.png";
              size = new Tmapv2.Size(24, 38);
            } else {
              markerImg = "http://topopen.tmap.co.kr/imgs/point.png";
              size = new Tmapv2.Size(8, 8);
            }

            const latlon = new Tmapv2.Point(
              geometry.coordinates[0],
              geometry.coordinates[1]
            );
            const convertPoint =
              new Tmapv2.Projection.convertEPSG3857ToWGS84GEO(latlon);

            const routeInfoObj = {
              markerImage: markerImg,
              lng: convertPoint._lng,
              lat: convertPoint._lat,
            };

            const marker_p = new Tmapv2.Marker({
              position: new Tmapv2.LatLng(routeInfoObj.lat, routeInfoObj.lng),
              icon: routeInfoObj.markerImage,
              iconSize: size,
              map: map,
            });

            resultdrawArr.push(marker_p);
          }
        });

        drawLine(drawInfoArr);
        moveMapCenterToMiddle(drawInfoArr); // Move center after drawing the route

        // Add 5 intermediate markers along the route
        const intermediatePoints = [
          new Tmapv2.LatLng(37.5652, 126.9855),
          new Tmapv2.LatLng(37.5655, 126.9865),
          new Tmapv2.LatLng(37.566, 126.987),
          new Tmapv2.LatLng(37.5662, 126.9875),
          new Tmapv2.LatLng(37.5665, 126.988),
        ];
        addIntermediateMarkers(intermediatePoints); // Pass intermediate points to add markers
      }

      // Draw polyline on the map
      function drawLine(arrPoint) {
        const polyline = new Tmapv2.Polyline({
          path: arrPoint,
          strokeColor: "#DD0000",
          strokeWeight: 6,
          map: map,
        });
        resultdrawArr.push(polyline);
      }

      // Move the map's center to the middle of the route
      function moveMapCenterToMiddle(points) {
        if (points.length === 0) return;

        // Calculate the midpoint of the route
        let latSum = 0;
        let lngSum = 0;

        points.forEach((point) => {
          latSum += point.lat(); // Use lat() method to get latitude
          lngSum += point.lng(); // Use lng() method to get longitude
        });

        const latMiddle = latSum / points.length;
        const lngMiddle = lngSum / points.length;

        // Move the map center to the calculated middle point
        map.setCenter(new Tmapv2.LatLng(latMiddle, lngMiddle));
      }

      // Add intermediate markers (5 points) to the route
      function addIntermediateMarkers(points) {
        points.forEach((point) => {
          const marker = new Tmapv2.Marker({
            position: point,
            icon: "http://topopen.tmap.co.kr/imgs/point.png",
            iconSize: new Tmapv2.Size(8, 8),
            map: map,
          });
          resultdrawArr.push(marker);
        });
      }

      // Initialize map and set up button click event
      window.onload = () => {
        initTmap();

        marker_s = new Tmapv2.Marker({
          position: new Tmapv2.LatLng(37.564991, 126.983937),
          icon: "/upload/tmap/marker/pin_r_m_s.png",
          iconSize: new Tmapv2.Size(24, 38),
          map: map,
        });

        marker_e = new Tmapv2.Marker({
          position: new Tmapv2.LatLng(37.566158, 126.98894),
          icon: "/upload/tmap/marker/pin_r_m_e.png",
          iconSize: new Tmapv2.Size(24, 38),
          map: map,
        });
      };

      // Attach event listener to the button to draw the route on the map
      document
        .getElementById("drawLineBtn")
        .addEventListener("click", async (e) => {
          const address = document.getElementById("address").value;
          e.preventDefault();
          const result = await gpt(address);
          console.log(result);
          fetchRouteData(); // Fetch route data when clicking the button
        });
    </script>
  </body>
</html>
